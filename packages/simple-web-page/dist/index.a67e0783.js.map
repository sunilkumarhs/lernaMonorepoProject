{"mappings":"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","sources":["<anon>","packages/simple-web-page/index.js","packages/ui-library/index.js","node_modules/snabbdom/build/init.js","node_modules/snabbdom/src/init.ts","node_modules/snabbdom/build/vnode.js","node_modules/snabbdom/src/vnode.ts","node_modules/snabbdom/build/is.js","node_modules/snabbdom/src/is.ts","node_modules/snabbdom/build/htmldomapi.js","node_modules/snabbdom/src/htmldomapi.ts","node_modules/snabbdom/build/h.js","node_modules/snabbdom/src/h.ts"],"sourcesContent":["function $4c5def158ca7e600$export$86f1c2e46be1e431(sel, data, children, text, elm) {\n    const key = data === undefined ? undefined : data.key;\n    return {\n        sel: sel,\n        data: data,\n        children: children,\n        text: text,\n        elm: elm,\n        key: key\n    };\n}\n\n\nconst $16ede8b8b5f2e5cd$export$2f23118c22fb2630 = Array.isArray;\nfunction $16ede8b8b5f2e5cd$export$f371853e3c41119(s) {\n    return typeof s === \"string\" || typeof s === \"number\" || s instanceof String || s instanceof Number;\n}\n\n\nfunction $2c092b85641ba483$var$createElement(tagName, options) {\n    return document.createElement(tagName, options);\n}\nfunction $2c092b85641ba483$var$createElementNS(namespaceURI, qualifiedName, options) {\n    return document.createElementNS(namespaceURI, qualifiedName, options);\n}\nfunction $2c092b85641ba483$var$createDocumentFragment() {\n    return $2c092b85641ba483$var$parseFragment(document.createDocumentFragment());\n}\nfunction $2c092b85641ba483$var$createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction $2c092b85641ba483$var$createComment(text) {\n    return document.createComment(text);\n}\nfunction $2c092b85641ba483$var$insertBefore(parentNode, newNode, referenceNode) {\n    if ($2c092b85641ba483$var$isDocumentFragment(parentNode)) {\n        let node = parentNode;\n        while(node && $2c092b85641ba483$var$isDocumentFragment(node)){\n            const fragment = $2c092b85641ba483$var$parseFragment(node);\n            node = fragment.parent;\n        }\n        parentNode = node !== null && node !== void 0 ? node : parentNode;\n    }\n    if ($2c092b85641ba483$var$isDocumentFragment(newNode)) newNode = $2c092b85641ba483$var$parseFragment(newNode, parentNode);\n    if (referenceNode && $2c092b85641ba483$var$isDocumentFragment(referenceNode)) referenceNode = $2c092b85641ba483$var$parseFragment(referenceNode).firstChildNode;\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction $2c092b85641ba483$var$removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction $2c092b85641ba483$var$appendChild(node, child) {\n    if ($2c092b85641ba483$var$isDocumentFragment(child)) child = $2c092b85641ba483$var$parseFragment(child, node);\n    node.appendChild(child);\n}\nfunction $2c092b85641ba483$var$parentNode(node) {\n    if ($2c092b85641ba483$var$isDocumentFragment(node)) {\n        while(node && $2c092b85641ba483$var$isDocumentFragment(node)){\n            const fragment = $2c092b85641ba483$var$parseFragment(node);\n            node = fragment.parent;\n        }\n        return node !== null && node !== void 0 ? node : null;\n    }\n    return node.parentNode;\n}\nfunction $2c092b85641ba483$var$nextSibling(node) {\n    var _a;\n    if ($2c092b85641ba483$var$isDocumentFragment(node)) {\n        const fragment = $2c092b85641ba483$var$parseFragment(node);\n        const parent = $2c092b85641ba483$var$parentNode(fragment);\n        if (parent && fragment.lastChildNode) {\n            const children = Array.from(parent.childNodes);\n            const index = children.indexOf(fragment.lastChildNode);\n            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;\n        }\n        return null;\n    }\n    return node.nextSibling;\n}\nfunction $2c092b85641ba483$var$tagName(elm) {\n    return elm.tagName;\n}\nfunction $2c092b85641ba483$var$setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction $2c092b85641ba483$var$getTextContent(node) {\n    return node.textContent;\n}\nfunction $2c092b85641ba483$var$isElement(node) {\n    return node.nodeType === 1;\n}\nfunction $2c092b85641ba483$var$isText(node) {\n    return node.nodeType === 3;\n}\nfunction $2c092b85641ba483$var$isComment(node) {\n    return node.nodeType === 8;\n}\nfunction $2c092b85641ba483$var$isDocumentFragment(node) {\n    return node.nodeType === 11;\n}\nfunction $2c092b85641ba483$var$parseFragment(fragmentNode, parentNode) {\n    var _a, _b, _c;\n    const fragment = fragmentNode;\n    (_a = fragment.parent) !== null && _a !== void 0 ? _a : fragment.parent = parentNode !== null && parentNode !== void 0 ? parentNode : null;\n    (_b = fragment.firstChildNode) !== null && _b !== void 0 ? _b : fragment.firstChildNode = fragmentNode.firstChild;\n    (_c = fragment.lastChildNode) !== null && _c !== void 0 ? _c : fragment.lastChildNode = fragmentNode.lastChild;\n    return fragment;\n}\nconst $2c092b85641ba483$export$b5620185d61e7315 = {\n    createElement: $2c092b85641ba483$var$createElement,\n    createElementNS: $2c092b85641ba483$var$createElementNS,\n    createTextNode: $2c092b85641ba483$var$createTextNode,\n    createDocumentFragment: $2c092b85641ba483$var$createDocumentFragment,\n    createComment: $2c092b85641ba483$var$createComment,\n    insertBefore: $2c092b85641ba483$var$insertBefore,\n    removeChild: $2c092b85641ba483$var$removeChild,\n    appendChild: $2c092b85641ba483$var$appendChild,\n    parentNode: $2c092b85641ba483$var$parentNode,\n    nextSibling: $2c092b85641ba483$var$nextSibling,\n    tagName: $2c092b85641ba483$var$tagName,\n    setTextContent: $2c092b85641ba483$var$setTextContent,\n    getTextContent: $2c092b85641ba483$var$getTextContent,\n    isElement: $2c092b85641ba483$var$isElement,\n    isText: $2c092b85641ba483$var$isText,\n    isComment: $2c092b85641ba483$var$isComment,\n    isDocumentFragment: $2c092b85641ba483$var$isDocumentFragment\n};\n\n\nfunction $bff19bc67166af17$var$isUndef(s) {\n    return s === undefined;\n}\nfunction $bff19bc67166af17$var$isDef(s) {\n    return s !== undefined;\n}\nconst $bff19bc67166af17$var$emptyNode = (0, $4c5def158ca7e600$export$86f1c2e46be1e431)(\"\", {}, [], undefined, undefined);\nfunction $bff19bc67166af17$var$sameVnode(vnode1, vnode2) {\n    var _a, _b;\n    const isSameKey = vnode1.key === vnode2.key;\n    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);\n    const isSameSel = vnode1.sel === vnode2.sel;\n    const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel ? typeof vnode1.text === typeof vnode2.text : true;\n    return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;\n}\n/**\n * @todo Remove this function when the document fragment is considered stable.\n */ function $bff19bc67166af17$var$documentFragmentIsNotSupported() {\n    throw new Error(\"The document fragment is not supported on this platform.\");\n}\nfunction $bff19bc67166af17$var$isElement(api, vnode) {\n    return api.isElement(vnode);\n}\nfunction $bff19bc67166af17$var$isDocumentFragment(api, vnode) {\n    return api.isDocumentFragment(vnode);\n}\nfunction $bff19bc67166af17$var$createKeyToOldIdx(children, beginIdx, endIdx) {\n    var _a;\n    const map = {};\n    for(let i = beginIdx; i <= endIdx; ++i){\n        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n        if (key !== undefined) map[key] = i;\n    }\n    return map;\n}\nconst $bff19bc67166af17$var$hooks = [\n    \"create\",\n    \"update\",\n    \"remove\",\n    \"destroy\",\n    \"pre\",\n    \"post\"\n];\nfunction $bff19bc67166af17$export$2cd8252107eb640b(modules, domApi, options) {\n    const cbs = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: []\n    };\n    const api = domApi !== undefined ? domApi : (0, $2c092b85641ba483$export$b5620185d61e7315);\n    for (const hook of $bff19bc67166af17$var$hooks)for (const module of modules){\n        const currentHook = module[hook];\n        if (currentHook !== undefined) cbs[hook].push(currentHook);\n    }\n    function emptyNodeAt(elm) {\n        const id = elm.id ? \"#\" + elm.id : \"\";\n        // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n        // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n        const classes = elm.getAttribute(\"class\");\n        const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n        return (0, $4c5def158ca7e600$export$86f1c2e46be1e431)(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function emptyDocumentFragmentAt(frag) {\n        return (0, $4c5def158ca7e600$export$86f1c2e46be1e431)(undefined, {}, [], undefined, frag);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                const parent = api.parentNode(childElm);\n                if (parent !== null) api.removeChild(parent, childElm);\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d;\n        let i;\n        let data = vnode.data;\n        if (data !== undefined) {\n            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n            if ($bff19bc67166af17$var$isDef(init)) {\n                init(vnode);\n                data = vnode.data;\n            }\n        }\n        const children = vnode.children;\n        const sel = vnode.sel;\n        if (sel === \"!\") {\n            if ($bff19bc67166af17$var$isUndef(vnode.text)) vnode.text = \"\";\n            vnode.elm = api.createComment(vnode.text);\n        } else if (sel === \"\") // textNode has no selector\n        vnode.elm = api.createTextNode(vnode.text);\n        else if (sel !== undefined) {\n            // Parse selector\n            const hashIdx = sel.indexOf(\"#\");\n            const dotIdx = sel.indexOf(\".\", hashIdx);\n            const hash = hashIdx > 0 ? hashIdx : sel.length;\n            const dot = dotIdx > 0 ? dotIdx : sel.length;\n            const tag = hashIdx !== -1 || dotIdx !== -1 ? sel.slice(0, Math.min(hash, dot)) : sel;\n            const elm = vnode.elm = $bff19bc67166af17$var$isDef(data) && $bff19bc67166af17$var$isDef(i = data.ns) ? api.createElementNS(i, tag, data) : api.createElement(tag, data);\n            if (hash < dot) elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n            if (dotIdx > 0) elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n            for(i = 0; i < cbs.create.length; ++i)cbs.create[i]($bff19bc67166af17$var$emptyNode, vnode);\n            if ($16ede8b8b5f2e5cd$export$f371853e3c41119(vnode.text) && (!$16ede8b8b5f2e5cd$export$2f23118c22fb2630(children) || children.length === 0)) // allow h1 and similar nodes to be created w/ text and empty child list\n            api.appendChild(elm, api.createTextNode(vnode.text));\n            if ($16ede8b8b5f2e5cd$export$2f23118c22fb2630(children)) for(i = 0; i < children.length; ++i){\n                const ch = children[i];\n                if (ch != null) api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n            }\n            const hook = vnode.data.hook;\n            if ($bff19bc67166af17$var$isDef(hook)) {\n                (_b = hook.create) === null || _b === void 0 || _b.call(hook, $bff19bc67166af17$var$emptyNode, vnode);\n                if (hook.insert) insertedVnodeQueue.push(vnode);\n            }\n        } else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode.children) {\n            vnode.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : $bff19bc67166af17$var$documentFragmentIsNotSupported)();\n            for(i = 0; i < cbs.create.length; ++i)cbs.create[i]($bff19bc67166af17$var$emptyNode, vnode);\n            for(i = 0; i < vnode.children.length; ++i){\n                const ch = vnode.children[i];\n                if (ch != null) api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));\n            }\n        } else vnode.elm = api.createTextNode(vnode.text);\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for(; startIdx <= endIdx; ++startIdx){\n            const ch = vnodes[startIdx];\n            if (ch != null) api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var _a, _b;\n        const data = vnode.data;\n        if (data !== undefined) {\n            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 || _b.call(_a, vnode);\n            for(let i = 0; i < cbs.destroy.length; ++i)cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) for(let j = 0; j < vnode.children.length; ++j){\n                const child = vnode.children[j];\n                if (child != null && typeof child !== \"string\") invokeDestroyHook(child);\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        var _a, _b;\n        for(; startIdx <= endIdx; ++startIdx){\n            let listeners;\n            let rm;\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                if ($bff19bc67166af17$var$isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for(let i = 0; i < cbs.remove.length; ++i)cbs.remove[i](ch, rm);\n                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;\n                    if ($bff19bc67166af17$var$isDef(removeHook)) removeHook(ch, rm);\n                    else rm();\n                } else if (ch.children) {\n                    // Fragment node\n                    invokeDestroyHook(ch);\n                    removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);\n                } else // Text node\n                api.removeChild(parentElm, ch.elm);\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        let oldStartIdx = 0;\n        let newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        let oldKeyToIdx;\n        let idxInOld;\n        let elmToMove;\n        let before;\n        while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){\n            if (oldStartVnode == null) oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            else if (oldEndVnode == null) oldEndVnode = oldCh[--oldEndIdx];\n            else if (newStartVnode == null) newStartVnode = newCh[++newStartIdx];\n            else if (newEndVnode == null) newEndVnode = newCh[--newEndIdx];\n            else if ($bff19bc67166af17$var$sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            } else if ($bff19bc67166af17$var$sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            } else if ($bff19bc67166af17$var$sameVnode(oldStartVnode, newEndVnode)) {\n                // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            } else if ($bff19bc67166af17$var$sameVnode(oldEndVnode, newStartVnode)) {\n                // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            } else {\n                if (oldKeyToIdx === undefined) oldKeyToIdx = $bff19bc67166af17$var$createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if ($bff19bc67166af17$var$isUndef(idxInOld)) {\n                    // `newStartVnode` is new, create and insert it in beginning\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    newStartVnode = newCh[++newStartIdx];\n                } else if ($bff19bc67166af17$var$isUndef(oldKeyToIdx[newEndVnode.key])) {\n                    // `newEndVnode` is new, create and insert it in the end\n                    api.insertBefore(parentElm, createElm(newEndVnode, insertedVnodeQueue), api.nextSibling(oldEndVnode.elm));\n                    newEndVnode = newCh[--newEndIdx];\n                } else {\n                    // Neither of the new endpoints are new vnodes, so we make progress by\n                    // moving `newStartVnode` into position\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                    newStartVnode = newCh[++newStartIdx];\n                }\n            }\n        }\n        if (newStartIdx <= newEndIdx) {\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        if (oldStartIdx <= oldEndIdx) removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 || _b.call(hook, oldVnode, vnode);\n        const elm = vnode.elm = oldVnode.elm;\n        if (oldVnode === vnode) return;\n        if (vnode.data !== undefined || $bff19bc67166af17$var$isDef(vnode.text) && vnode.text !== oldVnode.text) {\n            (_c = vnode.data) !== null && _c !== void 0 ? _c : vnode.data = {};\n            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : oldVnode.data = {};\n            for(let i = 0; i < cbs.update.length; ++i)cbs.update[i](oldVnode, vnode);\n            (_g = (_f = (_e = vnode.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 || _g.call(_f, oldVnode, vnode);\n        }\n        const oldCh = oldVnode.children;\n        const ch = vnode.children;\n        if ($bff19bc67166af17$var$isUndef(vnode.text)) {\n            if ($bff19bc67166af17$var$isDef(oldCh) && $bff19bc67166af17$var$isDef(ch)) {\n                if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            } else if ($bff19bc67166af17$var$isDef(ch)) {\n                if ($bff19bc67166af17$var$isDef(oldVnode.text)) api.setTextContent(elm, \"\");\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            } else if ($bff19bc67166af17$var$isDef(oldCh)) removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            else if ($bff19bc67166af17$var$isDef(oldVnode.text)) api.setTextContent(elm, \"\");\n        } else if (oldVnode.text !== vnode.text) {\n            if ($bff19bc67166af17$var$isDef(oldCh)) removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            api.setTextContent(elm, vnode.text);\n        }\n        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 || _h.call(hook, oldVnode, vnode);\n    }\n    return function patch(oldVnode, vnode) {\n        let i, elm, parent;\n        const insertedVnodeQueue = [];\n        for(i = 0; i < cbs.pre.length; ++i)cbs.pre[i]();\n        if ($bff19bc67166af17$var$isElement(api, oldVnode)) oldVnode = emptyNodeAt(oldVnode);\n        else if ($bff19bc67166af17$var$isDocumentFragment(api, oldVnode)) oldVnode = emptyDocumentFragmentAt(oldVnode);\n        if ($bff19bc67166af17$var$sameVnode(oldVnode, vnode)) patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [\n                    oldVnode\n                ], 0, 0);\n            }\n        }\n        for(i = 0; i < insertedVnodeQueue.length; ++i)insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        for(i = 0; i < cbs.post.length; ++i)cbs.post[i]();\n        return vnode;\n    };\n}\n\n\n\n\nfunction $67b9dcc5a2eef4f6$export$588773bb5c18f715(data, children, sel) {\n    data.ns = \"http://www.w3.org/2000/svg\";\n    if (sel !== \"foreignObject\" && children !== undefined) for(let i = 0; i < children.length; ++i){\n        const child = children[i];\n        if (typeof child === \"string\") continue;\n        const childData = child.data;\n        if (childData !== undefined) $67b9dcc5a2eef4f6$export$588773bb5c18f715(childData, child.children, child.sel);\n    }\n}\nfunction $67b9dcc5a2eef4f6$export$dda1d9f60106f0e9(sel, b, c) {\n    let data = {};\n    let children;\n    let text;\n    let i;\n    if (c !== undefined) {\n        if (b !== null) data = b;\n        if ($16ede8b8b5f2e5cd$export$2f23118c22fb2630(c)) children = c;\n        else if ($16ede8b8b5f2e5cd$export$f371853e3c41119(c)) text = c.toString();\n        else if (c && c.sel) children = [\n            c\n        ];\n    } else if (b !== undefined && b !== null) {\n        if ($16ede8b8b5f2e5cd$export$2f23118c22fb2630(b)) children = b;\n        else if ($16ede8b8b5f2e5cd$export$f371853e3c41119(b)) text = b.toString();\n        else if (b && b.sel) children = [\n            b\n        ];\n        else data = b;\n    }\n    if (children !== undefined) {\n        for(i = 0; i < children.length; ++i)if ($16ede8b8b5f2e5cd$export$f371853e3c41119(children[i])) children[i] = (0, $4c5def158ca7e600$export$86f1c2e46be1e431)(undefined, undefined, undefined, children[i], undefined);\n    }\n    if (sel.startsWith(\"svg\") && (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) $67b9dcc5a2eef4f6$export$588773bb5c18f715(data, children, sel);\n    return (0, $4c5def158ca7e600$export$86f1c2e46be1e431)(sel, data, children, text, undefined);\n}\nfunction $67b9dcc5a2eef4f6$export$f00aeb236b6f05af(children) {\n    let c;\n    let text;\n    if ($16ede8b8b5f2e5cd$export$2f23118c22fb2630(children)) c = children;\n    else if ($16ede8b8b5f2e5cd$export$f371853e3c41119(c)) text = children;\n    else if (c && c.sel) c = [\n        children\n    ];\n    if (c !== undefined) {\n        for(let i = 0; i < c.length; ++i)if ($16ede8b8b5f2e5cd$export$f371853e3c41119(c[i])) c[i] = (0, $4c5def158ca7e600$export$86f1c2e46be1e431)(undefined, undefined, undefined, c[i], undefined);\n    }\n    return (0, $4c5def158ca7e600$export$86f1c2e46be1e431)(undefined, {}, c, text, undefined);\n}\n\n\nconst $47ab3206db4a8fc4$var$patch = (0, $bff19bc67166af17$export$2cd8252107eb640b)([]);\nlet $47ab3206db4a8fc4$var$state = {\n    count: 0\n};\nlet $47ab3206db4a8fc4$var$updateCallback;\nfunction $47ab3206db4a8fc4$export$4e373c34abfa8c68(container, template) {\n    function updateState(newState) {\n        $47ab3206db4a8fc4$var$state = {\n            ...$47ab3206db4a8fc4$var$state,\n            ...newState\n        };\n        $47ab3206db4a8fc4$var$updateCallback();\n    }\n    function mount() {\n        console.log(\"Component mounted\");\n    }\n    function update() {\n        console.log(\"State changed:\", $47ab3206db4a8fc4$var$state);\n    }\n    function render() {\n        const newVNode = template($47ab3206db4a8fc4$var$state, updateState);\n        $47ab3206db4a8fc4$var$patch(container, newVNode);\n    }\n    $47ab3206db4a8fc4$var$updateCallback = ()=>{\n        update();\n        render();\n    };\n    mount();\n    render();\n}\n\n\nconst $ca9893d15183aa11$var$appContainer = document.getElementById(\"app\");\nconst $ca9893d15183aa11$var$template = (state, updateState)=>{\n    return (0, $67b9dcc5a2eef4f6$export$dda1d9f60106f0e9)(\"div\", [\n        (0, $67b9dcc5a2eef4f6$export$dda1d9f60106f0e9)(\"h1\", state.count),\n        (0, $67b9dcc5a2eef4f6$export$dda1d9f60106f0e9)(\"button\", {\n            on: {\n                click: ()=>updateState({\n                        count: state.count + 1\n                    })\n            }\n        }, \"Add\")\n    ]);\n};\n(0, $47ab3206db4a8fc4$export$4e373c34abfa8c68)($ca9893d15183aa11$var$appContainer, $ca9893d15183aa11$var$template);\n\n\n//# sourceMappingURL=index.a67e0783.js.map\n","import { createApp, h } from \"ui-library/index\";\r\n\r\nconst appContainer = document.getElementById(\"app\");\r\n\r\nconst template = (state, updateState) => {\r\n  return h(\"div\", [\r\n    h(\"h1\", state.count),\r\n    h(\r\n      \"button\",\r\n      { on: { click: () => updateState({ count: state.count + 1 }) } },\r\n      \"Add\"\r\n    ),\r\n  ]);\r\n};\r\n\r\ncreateApp(appContainer, template);\r\n","import { init } from \"snabbdom/build/init\";\r\nimport { h } from \"snabbdom/build/h\";\r\n\r\nconst patch = init([]);\r\n\r\nlet state = { count: 0 };\r\nlet updateCallback;\r\n\r\nexport function createApp(container, template) {\r\n  function updateState(newState) {\r\n    state = { ...state, ...newState };\r\n    updateCallback();\r\n  }\r\n\r\n  function mount() {\r\n    console.log(\"Component mounted\");\r\n  }\r\n\r\n  function update() {\r\n    console.log(\"State changed:\", state);\r\n  }\r\n\r\n  function render() {\r\n    const newVNode = template(state, updateState);\r\n    patch(container, newVNode);\r\n  }\r\n\r\n  updateCallback = () => {\r\n    update();\r\n    render();\r\n  };\r\n\r\n  mount();\r\n  render();\r\n}\r\n\r\nexport { h };\r\n","import { vnode } from \"./vnode.js\";\nimport * as is from \"./is.js\";\nimport { htmlDomApi } from \"./htmldomapi.js\";\nfunction isUndef(s) {\n    return s === undefined;\n}\nfunction isDef(s) {\n    return s !== undefined;\n}\nconst emptyNode = vnode(\"\", {}, [], undefined, undefined);\nfunction sameVnode(vnode1, vnode2) {\n    var _a, _b;\n    const isSameKey = vnode1.key === vnode2.key;\n    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);\n    const isSameSel = vnode1.sel === vnode2.sel;\n    const isSameTextOrFragment = !vnode1.sel && vnode1.sel === vnode2.sel\n        ? typeof vnode1.text === typeof vnode2.text\n        : true;\n    return isSameSel && isSameKey && isSameIs && isSameTextOrFragment;\n}\n/**\n * @todo Remove this function when the document fragment is considered stable.\n */\nfunction documentFragmentIsNotSupported() {\n    throw new Error(\"The document fragment is not supported on this platform.\");\n}\nfunction isElement(api, vnode) {\n    return api.isElement(vnode);\n}\nfunction isDocumentFragment(api, vnode) {\n    return api.isDocumentFragment(vnode);\n}\nfunction createKeyToOldIdx(children, beginIdx, endIdx) {\n    var _a;\n    const map = {};\n    for (let i = beginIdx; i <= endIdx; ++i) {\n        const key = (_a = children[i]) === null || _a === void 0 ? void 0 : _a.key;\n        if (key !== undefined) {\n            map[key] = i;\n        }\n    }\n    return map;\n}\nconst hooks = [\n    \"create\",\n    \"update\",\n    \"remove\",\n    \"destroy\",\n    \"pre\",\n    \"post\"\n];\nexport function init(modules, domApi, options) {\n    const cbs = {\n        create: [],\n        update: [],\n        remove: [],\n        destroy: [],\n        pre: [],\n        post: []\n    };\n    const api = domApi !== undefined ? domApi : htmlDomApi;\n    for (const hook of hooks) {\n        for (const module of modules) {\n            const currentHook = module[hook];\n            if (currentHook !== undefined) {\n                cbs[hook].push(currentHook);\n            }\n        }\n    }\n    function emptyNodeAt(elm) {\n        const id = elm.id ? \"#\" + elm.id : \"\";\n        // elm.className doesn't return a string when elm is an SVG element inside a shadowRoot.\n        // https://stackoverflow.com/questions/29454340/detecting-classname-of-svganimatedstring\n        const classes = elm.getAttribute(\"class\");\n        const c = classes ? \".\" + classes.split(\" \").join(\".\") : \"\";\n        return vnode(api.tagName(elm).toLowerCase() + id + c, {}, [], undefined, elm);\n    }\n    function emptyDocumentFragmentAt(frag) {\n        return vnode(undefined, {}, [], undefined, frag);\n    }\n    function createRmCb(childElm, listeners) {\n        return function rmCb() {\n            if (--listeners === 0) {\n                const parent = api.parentNode(childElm);\n                if (parent !== null) {\n                    api.removeChild(parent, childElm);\n                }\n            }\n        };\n    }\n    function createElm(vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d;\n        let i;\n        let data = vnode.data;\n        if (data !== undefined) {\n            const init = (_a = data.hook) === null || _a === void 0 ? void 0 : _a.init;\n            if (isDef(init)) {\n                init(vnode);\n                data = vnode.data;\n            }\n        }\n        const children = vnode.children;\n        const sel = vnode.sel;\n        if (sel === \"!\") {\n            if (isUndef(vnode.text)) {\n                vnode.text = \"\";\n            }\n            vnode.elm = api.createComment(vnode.text);\n        }\n        else if (sel === \"\") {\n            // textNode has no selector\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        else if (sel !== undefined) {\n            // Parse selector\n            const hashIdx = sel.indexOf(\"#\");\n            const dotIdx = sel.indexOf(\".\", hashIdx);\n            const hash = hashIdx > 0 ? hashIdx : sel.length;\n            const dot = dotIdx > 0 ? dotIdx : sel.length;\n            const tag = hashIdx !== -1 || dotIdx !== -1\n                ? sel.slice(0, Math.min(hash, dot))\n                : sel;\n            const elm = (vnode.elm =\n                isDef(data) && isDef((i = data.ns))\n                    ? api.createElementNS(i, tag, data)\n                    : api.createElement(tag, data));\n            if (hash < dot)\n                elm.setAttribute(\"id\", sel.slice(hash + 1, dot));\n            if (dotIdx > 0)\n                elm.setAttribute(\"class\", sel.slice(dot + 1).replace(/\\./g, \" \"));\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            if (is.primitive(vnode.text) &&\n                (!is.array(children) || children.length === 0)) {\n                // allow h1 and similar nodes to be created w/ text and empty child list\n                api.appendChild(elm, api.createTextNode(vnode.text));\n            }\n            if (is.array(children)) {\n                for (i = 0; i < children.length; ++i) {\n                    const ch = children[i];\n                    if (ch != null) {\n                        api.appendChild(elm, createElm(ch, insertedVnodeQueue));\n                    }\n                }\n            }\n            const hook = vnode.data.hook;\n            if (isDef(hook)) {\n                (_b = hook.create) === null || _b === void 0 ? void 0 : _b.call(hook, emptyNode, vnode);\n                if (hook.insert) {\n                    insertedVnodeQueue.push(vnode);\n                }\n            }\n        }\n        else if (((_c = options === null || options === void 0 ? void 0 : options.experimental) === null || _c === void 0 ? void 0 : _c.fragments) && vnode.children) {\n            vnode.elm = ((_d = api.createDocumentFragment) !== null && _d !== void 0 ? _d : documentFragmentIsNotSupported)();\n            for (i = 0; i < cbs.create.length; ++i)\n                cbs.create[i](emptyNode, vnode);\n            for (i = 0; i < vnode.children.length; ++i) {\n                const ch = vnode.children[i];\n                if (ch != null) {\n                    api.appendChild(vnode.elm, createElm(ch, insertedVnodeQueue));\n                }\n            }\n        }\n        else {\n            vnode.elm = api.createTextNode(vnode.text);\n        }\n        return vnode.elm;\n    }\n    function addVnodes(parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n        for (; startIdx <= endIdx; ++startIdx) {\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                api.insertBefore(parentElm, createElm(ch, insertedVnodeQueue), before);\n            }\n        }\n    }\n    function invokeDestroyHook(vnode) {\n        var _a, _b;\n        const data = vnode.data;\n        if (data !== undefined) {\n            (_b = (_a = data === null || data === void 0 ? void 0 : data.hook) === null || _a === void 0 ? void 0 : _a.destroy) === null || _b === void 0 ? void 0 : _b.call(_a, vnode);\n            for (let i = 0; i < cbs.destroy.length; ++i)\n                cbs.destroy[i](vnode);\n            if (vnode.children !== undefined) {\n                for (let j = 0; j < vnode.children.length; ++j) {\n                    const child = vnode.children[j];\n                    if (child != null && typeof child !== \"string\") {\n                        invokeDestroyHook(child);\n                    }\n                }\n            }\n        }\n    }\n    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {\n        var _a, _b;\n        for (; startIdx <= endIdx; ++startIdx) {\n            let listeners;\n            let rm;\n            const ch = vnodes[startIdx];\n            if (ch != null) {\n                if (isDef(ch.sel)) {\n                    invokeDestroyHook(ch);\n                    listeners = cbs.remove.length + 1;\n                    rm = createRmCb(ch.elm, listeners);\n                    for (let i = 0; i < cbs.remove.length; ++i)\n                        cbs.remove[i](ch, rm);\n                    const removeHook = (_b = (_a = ch === null || ch === void 0 ? void 0 : ch.data) === null || _a === void 0 ? void 0 : _a.hook) === null || _b === void 0 ? void 0 : _b.remove;\n                    if (isDef(removeHook)) {\n                        removeHook(ch, rm);\n                    }\n                    else {\n                        rm();\n                    }\n                }\n                else if (ch.children) {\n                    // Fragment node\n                    invokeDestroyHook(ch);\n                    removeVnodes(parentElm, ch.children, 0, ch.children.length - 1);\n                }\n                else {\n                    // Text node\n                    api.removeChild(parentElm, ch.elm);\n                }\n            }\n        }\n    }\n    function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue) {\n        let oldStartIdx = 0;\n        let newStartIdx = 0;\n        let oldEndIdx = oldCh.length - 1;\n        let oldStartVnode = oldCh[0];\n        let oldEndVnode = oldCh[oldEndIdx];\n        let newEndIdx = newCh.length - 1;\n        let newStartVnode = newCh[0];\n        let newEndVnode = newCh[newEndIdx];\n        let oldKeyToIdx;\n        let idxInOld;\n        let elmToMove;\n        let before;\n        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n            if (oldStartVnode == null) {\n                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left\n            }\n            else if (oldEndVnode == null) {\n                oldEndVnode = oldCh[--oldEndIdx];\n            }\n            else if (newStartVnode == null) {\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (newEndVnode == null) {\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newStartVnode)) {\n                patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n                oldStartVnode = oldCh[++oldStartIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else if (sameVnode(oldEndVnode, newEndVnode)) {\n                patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldStartVnode, newEndVnode)) {\n                // Vnode moved right\n                patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldStartVnode.elm, api.nextSibling(oldEndVnode.elm));\n                oldStartVnode = oldCh[++oldStartIdx];\n                newEndVnode = newCh[--newEndIdx];\n            }\n            else if (sameVnode(oldEndVnode, newStartVnode)) {\n                // Vnode moved left\n                patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n                api.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n                oldEndVnode = oldCh[--oldEndIdx];\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                if (oldKeyToIdx === undefined) {\n                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);\n                }\n                idxInOld = oldKeyToIdx[newStartVnode.key];\n                if (isUndef(idxInOld)) {\n                    // `newStartVnode` is new, create and insert it in beginning\n                    api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    newStartVnode = newCh[++newStartIdx];\n                }\n                else if (isUndef(oldKeyToIdx[newEndVnode.key])) {\n                    // `newEndVnode` is new, create and insert it in the end\n                    api.insertBefore(parentElm, createElm(newEndVnode, insertedVnodeQueue), api.nextSibling(oldEndVnode.elm));\n                    newEndVnode = newCh[--newEndIdx];\n                }\n                else {\n                    // Neither of the new endpoints are new vnodes, so we make progress by\n                    // moving `newStartVnode` into position\n                    elmToMove = oldCh[idxInOld];\n                    if (elmToMove.sel !== newStartVnode.sel) {\n                        api.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n                    }\n                    else {\n                        patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n                        oldCh[idxInOld] = undefined;\n                        api.insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm);\n                    }\n                    newStartVnode = newCh[++newStartIdx];\n                }\n            }\n        }\n        if (newStartIdx <= newEndIdx) {\n            before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm;\n            addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n        }\n        if (oldStartIdx <= oldEndIdx) {\n            removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n        }\n    }\n    function patchVnode(oldVnode, vnode, insertedVnodeQueue) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const hook = (_a = vnode.data) === null || _a === void 0 ? void 0 : _a.hook;\n        (_b = hook === null || hook === void 0 ? void 0 : hook.prepatch) === null || _b === void 0 ? void 0 : _b.call(hook, oldVnode, vnode);\n        const elm = (vnode.elm = oldVnode.elm);\n        if (oldVnode === vnode)\n            return;\n        if (vnode.data !== undefined ||\n            (isDef(vnode.text) && vnode.text !== oldVnode.text)) {\n            (_c = vnode.data) !== null && _c !== void 0 ? _c : (vnode.data = {});\n            (_d = oldVnode.data) !== null && _d !== void 0 ? _d : (oldVnode.data = {});\n            for (let i = 0; i < cbs.update.length; ++i)\n                cbs.update[i](oldVnode, vnode);\n            (_g = (_f = (_e = vnode.data) === null || _e === void 0 ? void 0 : _e.hook) === null || _f === void 0 ? void 0 : _f.update) === null || _g === void 0 ? void 0 : _g.call(_f, oldVnode, vnode);\n        }\n        const oldCh = oldVnode.children;\n        const ch = vnode.children;\n        if (isUndef(vnode.text)) {\n            if (isDef(oldCh) && isDef(ch)) {\n                if (oldCh !== ch)\n                    updateChildren(elm, oldCh, ch, insertedVnodeQueue);\n            }\n            else if (isDef(ch)) {\n                if (isDef(oldVnode.text))\n                    api.setTextContent(elm, \"\");\n                addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n            }\n            else if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            else if (isDef(oldVnode.text)) {\n                api.setTextContent(elm, \"\");\n            }\n        }\n        else if (oldVnode.text !== vnode.text) {\n            if (isDef(oldCh)) {\n                removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n            }\n            api.setTextContent(elm, vnode.text);\n        }\n        (_h = hook === null || hook === void 0 ? void 0 : hook.postpatch) === null || _h === void 0 ? void 0 : _h.call(hook, oldVnode, vnode);\n    }\n    return function patch(oldVnode, vnode) {\n        let i, elm, parent;\n        const insertedVnodeQueue = [];\n        for (i = 0; i < cbs.pre.length; ++i)\n            cbs.pre[i]();\n        if (isElement(api, oldVnode)) {\n            oldVnode = emptyNodeAt(oldVnode);\n        }\n        else if (isDocumentFragment(api, oldVnode)) {\n            oldVnode = emptyDocumentFragmentAt(oldVnode);\n        }\n        if (sameVnode(oldVnode, vnode)) {\n            patchVnode(oldVnode, vnode, insertedVnodeQueue);\n        }\n        else {\n            elm = oldVnode.elm;\n            parent = api.parentNode(elm);\n            createElm(vnode, insertedVnodeQueue);\n            if (parent !== null) {\n                api.insertBefore(parent, vnode.elm, api.nextSibling(elm));\n                removeVnodes(parent, [oldVnode], 0, 0);\n            }\n        }\n        for (i = 0; i < insertedVnodeQueue.length; ++i) {\n            insertedVnodeQueue[i].data.hook.insert(insertedVnodeQueue[i]);\n        }\n        for (i = 0; i < cbs.post.length; ++i)\n            cbs.post[i]();\n        return vnode;\n    };\n}\n//# sourceMappingURL=init.js.map",null,"export function vnode(sel, data, children, text, elm) {\n    const key = data === undefined ? undefined : data.key;\n    return { sel, data, children, text, elm, key };\n}\n//# sourceMappingURL=vnode.js.map",null,"export const array = Array.isArray;\nexport function primitive(s) {\n    return (typeof s === \"string\" ||\n        typeof s === \"number\" ||\n        s instanceof String ||\n        s instanceof Number);\n}\n//# sourceMappingURL=is.js.map",null,"function createElement(tagName, options) {\n    return document.createElement(tagName, options);\n}\nfunction createElementNS(namespaceURI, qualifiedName, options) {\n    return document.createElementNS(namespaceURI, qualifiedName, options);\n}\nfunction createDocumentFragment() {\n    return parseFragment(document.createDocumentFragment());\n}\nfunction createTextNode(text) {\n    return document.createTextNode(text);\n}\nfunction createComment(text) {\n    return document.createComment(text);\n}\nfunction insertBefore(parentNode, newNode, referenceNode) {\n    if (isDocumentFragment(parentNode)) {\n        let node = parentNode;\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        parentNode = node !== null && node !== void 0 ? node : parentNode;\n    }\n    if (isDocumentFragment(newNode)) {\n        newNode = parseFragment(newNode, parentNode);\n    }\n    if (referenceNode && isDocumentFragment(referenceNode)) {\n        referenceNode = parseFragment(referenceNode).firstChildNode;\n    }\n    parentNode.insertBefore(newNode, referenceNode);\n}\nfunction removeChild(node, child) {\n    node.removeChild(child);\n}\nfunction appendChild(node, child) {\n    if (isDocumentFragment(child)) {\n        child = parseFragment(child, node);\n    }\n    node.appendChild(child);\n}\nfunction parentNode(node) {\n    if (isDocumentFragment(node)) {\n        while (node && isDocumentFragment(node)) {\n            const fragment = parseFragment(node);\n            node = fragment.parent;\n        }\n        return node !== null && node !== void 0 ? node : null;\n    }\n    return node.parentNode;\n}\nfunction nextSibling(node) {\n    var _a;\n    if (isDocumentFragment(node)) {\n        const fragment = parseFragment(node);\n        const parent = parentNode(fragment);\n        if (parent && fragment.lastChildNode) {\n            const children = Array.from(parent.childNodes);\n            const index = children.indexOf(fragment.lastChildNode);\n            return (_a = children[index + 1]) !== null && _a !== void 0 ? _a : null;\n        }\n        return null;\n    }\n    return node.nextSibling;\n}\nfunction tagName(elm) {\n    return elm.tagName;\n}\nfunction setTextContent(node, text) {\n    node.textContent = text;\n}\nfunction getTextContent(node) {\n    return node.textContent;\n}\nfunction isElement(node) {\n    return node.nodeType === 1;\n}\nfunction isText(node) {\n    return node.nodeType === 3;\n}\nfunction isComment(node) {\n    return node.nodeType === 8;\n}\nfunction isDocumentFragment(node) {\n    return node.nodeType === 11;\n}\nfunction parseFragment(fragmentNode, parentNode) {\n    var _a, _b, _c;\n    const fragment = fragmentNode;\n    (_a = fragment.parent) !== null && _a !== void 0 ? _a : (fragment.parent = parentNode !== null && parentNode !== void 0 ? parentNode : null);\n    (_b = fragment.firstChildNode) !== null && _b !== void 0 ? _b : (fragment.firstChildNode = fragmentNode.firstChild);\n    (_c = fragment.lastChildNode) !== null && _c !== void 0 ? _c : (fragment.lastChildNode = fragmentNode.lastChild);\n    return fragment;\n}\nexport const htmlDomApi = {\n    createElement,\n    createElementNS,\n    createTextNode,\n    createDocumentFragment,\n    createComment,\n    insertBefore,\n    removeChild,\n    appendChild,\n    parentNode,\n    nextSibling,\n    tagName,\n    setTextContent,\n    getTextContent,\n    isElement,\n    isText,\n    isComment,\n    isDocumentFragment\n};\n//# sourceMappingURL=htmldomapi.js.map",null,"import { vnode } from \"./vnode.js\";\nimport * as is from \"./is.js\";\nexport function addNS(data, children, sel) {\n    data.ns = \"http://www.w3.org/2000/svg\";\n    if (sel !== \"foreignObject\" && children !== undefined) {\n        for (let i = 0; i < children.length; ++i) {\n            const child = children[i];\n            if (typeof child === \"string\")\n                continue;\n            const childData = child.data;\n            if (childData !== undefined) {\n                addNS(childData, child.children, child.sel);\n            }\n        }\n    }\n}\nexport function h(sel, b, c) {\n    let data = {};\n    let children;\n    let text;\n    let i;\n    if (c !== undefined) {\n        if (b !== null) {\n            data = b;\n        }\n        if (is.array(c)) {\n            children = c;\n        }\n        else if (is.primitive(c)) {\n            text = c.toString();\n        }\n        else if (c && c.sel) {\n            children = [c];\n        }\n    }\n    else if (b !== undefined && b !== null) {\n        if (is.array(b)) {\n            children = b;\n        }\n        else if (is.primitive(b)) {\n            text = b.toString();\n        }\n        else if (b && b.sel) {\n            children = [b];\n        }\n        else {\n            data = b;\n        }\n    }\n    if (children !== undefined) {\n        for (i = 0; i < children.length; ++i) {\n            if (is.primitive(children[i]))\n                children[i] = vnode(undefined, undefined, undefined, children[i], undefined);\n        }\n    }\n    if (sel.startsWith(\"svg\") &&\n        (sel.length === 3 || sel[3] === \".\" || sel[3] === \"#\")) {\n        addNS(data, children, sel);\n    }\n    return vnode(sel, data, children, text, undefined);\n}\n/**\n * @experimental\n */\nexport function fragment(children) {\n    let c;\n    let text;\n    if (is.array(children)) {\n        c = children;\n    }\n    else if (is.primitive(c)) {\n        text = children;\n    }\n    else if (c && c.sel) {\n        c = [children];\n    }\n    if (c !== undefined) {\n        for (let i = 0; i < c.length; ++i) {\n            if (is.primitive(c[i]))\n                c[i] = vnode(undefined, undefined, undefined, c[i], undefined);\n        }\n    }\n    return vnode(undefined, {}, c, text, undefined);\n}\n//# sourceMappingURL=h.js.map",null],"names":["$47ab3206db4a8fc4$var$updateCallback","$4c5def158ca7e600$export$86f1c2e46be1e431","sel","data","children","text","elm","key","undefined","$16ede8b8b5f2e5cd$export$2f23118c22fb2630","Array","isArray","$16ede8b8b5f2e5cd$export$f371853e3c41119","s","String","Number","$2c092b85641ba483$var$parentNode","node","$2c092b85641ba483$var$isDocumentFragment","fragment","$2c092b85641ba483$var$parseFragment","parent","parentNode","nodeType","fragmentNode","_a","_b","_c","firstChildNode","firstChild","lastChildNode","lastChild","$2c092b85641ba483$export$b5620185d61e7315","createElement","tagName","options","document","createElementNS","namespaceURI","qualifiedName","createTextNode","createDocumentFragment","createComment","insertBefore","newNode","referenceNode","removeChild","child","appendChild","nextSibling","from","childNodes","index","indexOf","setTextContent","textContent","getTextContent","isElement","isText","isComment","isDocumentFragment","$bff19bc67166af17$var$isUndef","$bff19bc67166af17$var$isDef","$bff19bc67166af17$var$emptyNode","$bff19bc67166af17$var$sameVnode","vnode1","vnode2","isSameKey","isSameIs","is","isSameSel","isSameTextOrFragment","$bff19bc67166af17$var$hooks","$67b9dcc5a2eef4f6$export$dda1d9f60106f0e9","b","c","i","toString","length","startsWith","$67b9dcc5a2eef4f6$export$588773bb5c18f715","ns","childData","$47ab3206db4a8fc4$var$patch","modules","domApi","cbs","create","update","remove","destroy","pre","post","hook","module","currentHook","push","createElm","vnode","insertedVnodeQueue","_d","init","api","hashIdx","dotIdx","hash","dot","tag","slice","Math","min","setAttribute","replace","ch","call","insert","addVnodes","parentElm","before","vnodes","startIdx","endIdx","invokeDestroyHook","j","removeVnodes","listeners","rm","createRmCb","childElm","removeHook","oldVnode","emptyNodeAt","id","classes","getAttribute","split","join","toLowerCase","patchVnode","_e","_f","_g","_h","prepatch","oldCh","updateChildren","newCh","oldKeyToIdx","idxInOld","elmToMove","oldStartIdx","newStartIdx","oldEndIdx","oldStartVnode","oldEndVnode","newEndIdx","newStartVnode","newEndVnode","$bff19bc67166af17$var$createKeyToOldIdx","beginIdx","map","postpatch","$47ab3206db4a8fc4$var$state","count","container","template","updateState","newState","render","console","log","getElementById","state","on","click"],"version":3,"file":"index.a67e0783.js.map"}